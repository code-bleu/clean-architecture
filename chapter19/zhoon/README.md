# 19장. 정책과 수준

## Introduction

- 소프트웨어 시스템이란 정책을 기술한 것
- 대다수의 주요 시스템에서 하나의 정책은 이 정책을 서술하는 여러 개의 조그만 정책들로 쪼갤 수 있음
- 소프트웨어 아키텍처를 개발하는 기술에는 이러한 정책을 신중하게 분리하고, 정책이 변경되는 양상에 따라 정책을 재편성하는 일도 포함됨
  - 동일한 이유로 동일한 시점에 변경되는 정책은 동일한 수준에 위치하며, 동일한 컴포넌트에 속해야 함
  - 서로 다른 이유로, 혹은 다른 시점에 변경되는 정책은 다른 수준에 위치하며, 반드시 다른 컴포넌트로 분리해야 함
- 흔히 아키텍처 개발은 재편성된 컴포넌트들을 비순환 방향 그래프로 구성하는 기술을 포함
- 좋은 아키텍처라면 각 컴포넌트를 연결할 때 의존성의 방향이 컴포넌트의 수준을 기반으로 연결되도록 만들어야 함
- 즉, 저수준의 컴포넌트가 고수준 컴포넌트에 의존하도록 설계되어야 함

## 수준

- 수준 level 을 엄밀하게 정의하자면 “입력과 출력까지의 거리”
- 시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아짐

![0.jpg](/clean-architecture/img/chapter19/0.jpg)

- 번역 컴포넌트는 이 시스템에서 최고 수준의 컴포넌트
- 주목할 점은 데이터 흐름과 소스 코드 의존성이 항상 같은 방향을 가리키지는 않는다는 사실
  - 이것이 바로 소프트웨어 아키텍처가 가진 예술 중 하나
- 소스 코드 의존성은 그 수준에 따라 결합되어야 하며, 데이터 흐름을 기준으로 결합되어서는 안 됨

![1.jpg](/clean-architecture/img/chapter19/1.jpg)

- 해당 경계로 묶인 영역이 이 시스템에서 최고 수준의 구성요소
- 입력과 출력에 변화가 생기더라도 암호화 정책은 거의 영향을 받지 않음
- 정책을 컴포넌트로 묶는 기준은 정책이 변경되는 방식에 달려있다는 사실
- 단일 책임 원칙과 공통 폐쇄 원칙에 따르면 동일한 이유로 동일한 시점에 변경되는 정책은 함께 묶임
- 고수준 정책
  - 입력과 출력에서 멀리 떨어진 정책
  - 저수준 정책에 비해 덜 빈번하게 변경되고, 보다 중요한 이유로 변경되는 경향이 있음
- 저수준 정책
  - 입력과 출력에 가까이 위치한 정책
  - 더 빈번하게 변경되며, 보다 긴급성을 요하며, 덜 중요한 이유로 변경되는 경향이 있음
- 모든 소스 코드 의존성의 방향이 고수준 정책을 향할 수 있도록 정책을 분리했다면 변경의 영향도를 줄일 수 있음
- 이 논의는 저수준 컴포넌트가 고수준 컴포넌트에 플러그인되어야 한다는 관점으로 바라볼 수 있음

![2.jpg](/clean-architecture/img/chapter19/2.jpg)

## 결론

- 이 장에서 설명한 정책에 대한 논의는 단일 책임 원칙, 개방 폐쇄 원칙, 공통 폐쇄 원칙, 의존성 역전 원칙, 안정된 의존성 원칙, 안정된 추상화 원칙을 모두 포함
