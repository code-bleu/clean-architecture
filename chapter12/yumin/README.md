# 12장. 컴포넌트

컴포넌트는 배포 단위다.

컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.

자바의 경우 jar파일이 컴포넌트다.

모든 언어에서 컴포넌트는 배포할 수 있는 단위 입자다.

여러 컴포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있다.

.war파일과 같은 단일 아카이브로 만들수도 있다.

### 컴포넌트의 간략한 역사

프로그래밍 초창기에는 프로그램을 로드할 메모리의 위치를 정하는 일이 프로그래머가 가장 먼저 결정해야 하는 사항 중 하나였다.

이걸 배치하고 나면 재배치가 불가능하였다.

이러한 구시대에는 라이브러리 함수에 어떻게 접근했나?

- 프로그래머가 라이브러리 함수의 소스 코드를 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일했다.

메모리는 비싸고, 한정적인 자원이었기 때문이다.

컴파일러는 소스 코드 전체를 여러 번에 걸쳐서 읽어야 했지만, 메모리가 너무 작아서 소스 코드 전체를 메모리에 상주시킬수가 없었다.

### 재배치성

해결책은 재배치가 가능한 바이너리였다.

지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하자는 것이었다.

프로그래머는 오직 필요한 함수만을 로드할 수 있게 되었다.

재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정되었다.

라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의로 생성했다.

이렇게 함으로써 외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 된다.

- 이렇게 링킹 로더가 탄생하였다.

### 결론

런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다.

여기까지 오는 데 50년이 걸렸다.

과거에는 초인적인 노력을 들여야만 컴포넌트 플러그인 아키텍처를 적용할 수 있었다. (지금과 다름)